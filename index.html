<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link rel="stylesheet" href="css/style.css">

    <title>CS-6043 Spring 2022 - Chan's Algorithm</title>
</head>

<body>
    <header class="navbar navbar-expand-lg bg-light navbar-light">
        <nav class="container-sm">
            <div id="bdNavbar" class="collapse navbar-collapse">
                <a class="navbar-brand" href="#">Home</a>

                <ul class="navbar-nav">
                    <li class="nav-item"><a class="nav-link" href="./demo.html">Demo</a></li>
                    <li class="nav-item"><a class="nav-link" href="./credits.html">Credits</a></li>
                </ul>
            </div>
        </nav>
    </header>

    <div class="container-sm py-md-3">
        <h2>Introduction</h2><hr>
        <p>
            <a href="https://en.wikipedia.org/wiki/Chan%27s_algorithm">Chan's algorithm</a> partitions the set of \(n\) points \(P\) into \(\Bigl\lceil \dfrac{n}{m} \Bigr\rceil\) groups of size at most \(m\) each. For each group \(P_1, P_2, ..., P_{\lceil n/m \rceil}\), we compute the convex hull. After the end of this step, we end up with \(\Bigl\lceil \dfrac{n}{m} \Bigr\rceil\) <i>mini</i> hulls. The figure below is an example with the outcome after this first step, i.e., we end up with four subsets of \(P\) each with \(\leq m\) points (and the mini hulls are constructed).<br>
            <!-- TODO: use picture from actual demo once that's working -->
            <center><img src="images/fig1.png"></center><br>

            <!-- TODO: details in between -->

            Now that we have the mini hulls, pick \(x_{max}\)
            
            On a high-level overview, Chan's algorithm goes through the following steps to achieve a convex hull of \(P\):
            <ol>
                <li>Parition \(P\) into \(\Bigl\lceil \dfrac{n}{m} \Bigr\rceil\) groups of size at most \(m\) each.</li>
                <li>Use Graham's Scan to find the convex hull of each group.</li>
                <li>Use Gift Wrapping to compute the convex hull of \(P\).</li>
            </ol>

            Several questions:<br>
            <ul>
                <li>How do we pick \(m\)?</li>
                <li>How do we start gift wrapping after computing the mini hulls?</li>
                <li>How do the steps introduced above lead to an \(O(n \log h)\) time algorithm for constructing convex hulls?</li>
            </ul>

            In the following sections, we explain the algorithm as described in Chan's paper, provide visualizations for each step of the algorithm, mention alternative solutions for certain steps, and go over extensions proposed by Chan.
        </p>
    </div>

    <div class="container-sm py-md-3">
        <h2>The Algorithm</h2><hr>
        <p>
            Now that we've given a high-level overview of how Chan's algorithm runs, we now go into the details of how the algorithm ultimately constructs the convex hull in \(O(n \log h)\) time.
        </p>
    </div>

    <div class="container-sm py-md-3">
        <h2>Extensions</h2><hr>
        <p>
            <!-- Extension ideas: -->
            <!-- 1. do we really need to start over from scratch if m is not large enough? -->
            <!-- 2. is binary searching needed to find tangents? could probably improve that part. -->
            <!-- Several options: brute force all tangents, binary search, or notice that on the next iteration, each tangent is either the same or one off in CCW direction -->
            <!-- 3. mention how to handle collinear cases and other edge cases. -->
            <!-- 4. how to avoid checking angle involving two of the same points in binary search step? -->
            <!-- 5. need to store mini hulls' points in CCW order with lowest y-value point at first index to avoid dealing with out-of-bounds indices in binary search. -->
        </p>
    </div>

    <!-- Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>

    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
